/**
 * @fileoverview Alt text validation and sanitization utilities.
 * Enforces accessibility best practices for image alt text.
 * @module main/utils/validation
 */

/** @type {string[]} Forbidden alt text prefixes that reduce accessibility */
const FORBIDDEN_PREFIXES = [
  'image of',
  'picture of',
  'photo of',
  'photograph of',
  'a image',
  'an image',
  'a photo',
  'an photo',
  'a picture',
  'an picture',
]

/**
 * @typedef {Object} ValidationResult
 * @property {boolean} valid - Whether the alt text passes all validation rules
 * @property {string[]} issues - List of validation issues found
 * @property {string} text - The trimmed input text
 */

/**
 * Validates alt text against accessibility best practices.
 * @param {string|undefined} text - Alt text to validate
 * @param {number} [maxLength=125] - Maximum allowed character length
 * @returns {ValidationResult} Validation result with issues
 */
export function validateAltText(text, maxLength = 125) {
  const issues = []

  if (text === undefined) {
    return { valid: false, issues: ['Missing alt text'], text: '' }
  }

  if (typeof text !== 'string') {
    return { valid: false, issues: ['Alt text must be a string'], text: '' }
  }

  const trimmed = text.trim()

  if (trimmed.length > maxLength) {
    issues.push(`Exceeds ${maxLength} characters (${trimmed.length})`)
  }

  const lower = trimmed.toLowerCase()
  for (const prefix of FORBIDDEN_PREFIXES) {
    if (lower.startsWith(prefix)) {
      issues.push(`Starts with forbidden prefix: "${prefix}"`)
      break
    }
  }

  if (/\.(jpg|jpeg|png|gif|webp|svg|bmp|tiff?)/i.test(trimmed)) {
    issues.push('Contains file extension')
  }

  if (/generated by ai|ai-generated|chatgpt|copilot|gpt-4|claude/i.test(trimmed)) {
    issues.push('Contains AI mention')
  }

  if (/^\w+[-_]\d+$/i.test(trimmed)) {
    issues.push('Appears to be a filename')
  }

  const words = trimmed.toLowerCase().split(/\s+/)
  const wordCount = {}
  for (const word of words) {
    if (word.length > 3) {
      wordCount[word] = (wordCount[word] || 0) + 1
    }
  }
  const repeatedWords = Object.entries(wordCount).filter(([, count]) => count > 2)
  if (repeatedWords.length > 0) {
    issues.push('Possible keyword stuffing detected')
  }

  return {
    valid: issues.length === 0,
    issues,
    text: trimmed,
  }
}

/**
 * Sanitizes alt text by removing forbidden prefixes and ensuring proper formatting.
 * @param {string|undefined} text - Alt text to sanitize
 * @param {number} [maxLength=125] - Maximum allowed character length
 * @returns {string} Sanitized alt text
 */
export function sanitizeAltText(text, maxLength = 125) {
  if (!text || typeof text !== 'string') {
    return ''
  }

  let sanitized = text.trim()

  const lower = sanitized.toLowerCase()
  for (const prefix of FORBIDDEN_PREFIXES) {
    if (lower.startsWith(prefix)) {
      sanitized = sanitized.slice(prefix.length).trim()
      if (sanitized.startsWith(',') || sanitized.startsWith(':')) {
        sanitized = sanitized.slice(1).trim()
      }
      break
    }
  }

  sanitized = sanitized.charAt(0).toUpperCase() + sanitized.slice(1)

  if (sanitized.length > maxLength) {
    sanitized = sanitized.slice(0, maxLength - 1).trim() + 'â€¦'
  }

  return sanitized
}
